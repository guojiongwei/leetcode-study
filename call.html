<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // Function.prototype.MyCall = function(context) {
      //   context = context || window
      //   const fn = Symbol('fn')
      //   console.log(context)
      //   context[fn] = this
      //   const res = context[fn](...[...arguments].slice(1))
      //   delete context[fn]
      //   return res
      // }

      function Test(a, b) {
        this.a = a;
        this.b = b;
      }
      // var obj = 1

      // function New(target, ...args) {
      //   if(typeof target !== 'function') {
      //     throw 'type error'
      //   }
      //   const obj = {}
      //   Object.setPrototypeOf(res, target.prototype)
      //   const res = target.apply(res, args)
      //   if((typeof res === 'object' || typeof res === 'function') && res !== null) {
      //     return res
      //   }
      //   return obj
      // }

      // Test.MyCall(obj, 1, 2)

      // console.log(obj)

      // function curry(fn, args=[]) {
      //   let length = fn.length
      //   return function(...newArgs) {
      //     newArgs =  newArgs.concat(args)
      //     if(newArgs.length < fn.length) {
      //       return curry.call(this, fn, newArgs)
      //     } else {
      //       return fn.apply(this, newArgs)
      //     }
      //   }
      // }
      // const curry =
      //   (fn, arr = []) =>
      //   (...args) =>
      //     ((arg) => (arg.length === fn.length ? fn(...arg) : curry(fn, arg)))([
      //       ...arr,
      //       ...args,
      //     ]);
      // function multiFn(a, b, c) {
      //   return a * b * c;
      // }

      // var multi = curry(multiFn);

      // console.log(multi(2)(3)(4));
      Function.prototype._bind = function(ctx, ...args) {
  // 下面的this就是调用_bind的函数,保存给_self
  const _self = this
  // bind 要返回一个函数, 就不会立即执行了
  const newFn = function(...rest) {
    // 调用 call 修改 this 指向
    return _self.call(ctx, ...args, ...rest)
  }
  if (_self.prototype) {
    // 复制源函数的prototype给newFn 一些情况下函数没有prototype，比如箭头函数
    newFn.prototype = Object.create(_self.prototype);
  }
  return newFn
}

      function Test(a, b) {
        console.log(a, b)
        this.a = a
        this.b = b
      }
      var obj = {}
      var fn = Test._bind(obj, 1)
      // console.log(fn(2))
      // console.log(new fn(2))
      console.log(new fn(1))
    </script>
  </body>
</html>
